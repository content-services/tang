// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package tangy

import (
	"context"

	mock "github.com/stretchr/testify/mock"
)

// NewMockTangy creates a new instance of MockTangy. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTangy(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTangy {
	mock := &MockTangy{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTangy is an autogenerated mock type for the Tangy type
type MockTangy struct {
	mock.Mock
}

type MockTangy_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTangy) EXPECT() *MockTangy_Expecter {
	return &MockTangy_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type MockTangy
func (_mock *MockTangy) Close() {
	_mock.Called()
	return
}

// MockTangy_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockTangy_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockTangy_Expecter) Close() *MockTangy_Close_Call {
	return &MockTangy_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockTangy_Close_Call) Run(run func()) *MockTangy_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockTangy_Close_Call) Return() *MockTangy_Close_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockTangy_Close_Call) RunAndReturn(run func()) *MockTangy_Close_Call {
	_c.Run(run)
	return _c
}

// RpmRepositoryVersionEnvironmentSearch provides a mock function for the type MockTangy
func (_mock *MockTangy) RpmRepositoryVersionEnvironmentSearch(ctx context.Context, hrefs []string, search string, limit int) ([]RpmEnvironmentSearch, error) {
	ret := _mock.Called(ctx, hrefs, search, limit)

	if len(ret) == 0 {
		panic("no return value specified for RpmRepositoryVersionEnvironmentSearch")
	}

	var r0 []RpmEnvironmentSearch
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, string, int) ([]RpmEnvironmentSearch, error)); ok {
		return returnFunc(ctx, hrefs, search, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, string, int) []RpmEnvironmentSearch); ok {
		r0 = returnFunc(ctx, hrefs, search, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]RpmEnvironmentSearch)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []string, string, int) error); ok {
		r1 = returnFunc(ctx, hrefs, search, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTangy_RpmRepositoryVersionEnvironmentSearch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RpmRepositoryVersionEnvironmentSearch'
type MockTangy_RpmRepositoryVersionEnvironmentSearch_Call struct {
	*mock.Call
}

// RpmRepositoryVersionEnvironmentSearch is a helper method to define mock.On call
//   - ctx context.Context
//   - hrefs []string
//   - search string
//   - limit int
func (_e *MockTangy_Expecter) RpmRepositoryVersionEnvironmentSearch(ctx interface{}, hrefs interface{}, search interface{}, limit interface{}) *MockTangy_RpmRepositoryVersionEnvironmentSearch_Call {
	return &MockTangy_RpmRepositoryVersionEnvironmentSearch_Call{Call: _e.mock.On("RpmRepositoryVersionEnvironmentSearch", ctx, hrefs, search, limit)}
}

func (_c *MockTangy_RpmRepositoryVersionEnvironmentSearch_Call) Run(run func(ctx context.Context, hrefs []string, search string, limit int)) *MockTangy_RpmRepositoryVersionEnvironmentSearch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockTangy_RpmRepositoryVersionEnvironmentSearch_Call) Return(rpmEnvironmentSearchs []RpmEnvironmentSearch, err error) *MockTangy_RpmRepositoryVersionEnvironmentSearch_Call {
	_c.Call.Return(rpmEnvironmentSearchs, err)
	return _c
}

func (_c *MockTangy_RpmRepositoryVersionEnvironmentSearch_Call) RunAndReturn(run func(ctx context.Context, hrefs []string, search string, limit int) ([]RpmEnvironmentSearch, error)) *MockTangy_RpmRepositoryVersionEnvironmentSearch_Call {
	_c.Call.Return(run)
	return _c
}

// RpmRepositoryVersionErrataList provides a mock function for the type MockTangy
func (_mock *MockTangy) RpmRepositoryVersionErrataList(ctx context.Context, hrefs []string, filterOpts ErrataListFilters, pageOpts PageOptions) ([]ErrataListItem, int, error) {
	ret := _mock.Called(ctx, hrefs, filterOpts, pageOpts)

	if len(ret) == 0 {
		panic("no return value specified for RpmRepositoryVersionErrataList")
	}

	var r0 []ErrataListItem
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, ErrataListFilters, PageOptions) ([]ErrataListItem, int, error)); ok {
		return returnFunc(ctx, hrefs, filterOpts, pageOpts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, ErrataListFilters, PageOptions) []ErrataListItem); ok {
		r0 = returnFunc(ctx, hrefs, filterOpts, pageOpts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ErrataListItem)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []string, ErrataListFilters, PageOptions) int); ok {
		r1 = returnFunc(ctx, hrefs, filterOpts, pageOpts)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, []string, ErrataListFilters, PageOptions) error); ok {
		r2 = returnFunc(ctx, hrefs, filterOpts, pageOpts)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockTangy_RpmRepositoryVersionErrataList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RpmRepositoryVersionErrataList'
type MockTangy_RpmRepositoryVersionErrataList_Call struct {
	*mock.Call
}

// RpmRepositoryVersionErrataList is a helper method to define mock.On call
//   - ctx context.Context
//   - hrefs []string
//   - filterOpts ErrataListFilters
//   - pageOpts PageOptions
func (_e *MockTangy_Expecter) RpmRepositoryVersionErrataList(ctx interface{}, hrefs interface{}, filterOpts interface{}, pageOpts interface{}) *MockTangy_RpmRepositoryVersionErrataList_Call {
	return &MockTangy_RpmRepositoryVersionErrataList_Call{Call: _e.mock.On("RpmRepositoryVersionErrataList", ctx, hrefs, filterOpts, pageOpts)}
}

func (_c *MockTangy_RpmRepositoryVersionErrataList_Call) Run(run func(ctx context.Context, hrefs []string, filterOpts ErrataListFilters, pageOpts PageOptions)) *MockTangy_RpmRepositoryVersionErrataList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		var arg2 ErrataListFilters
		if args[2] != nil {
			arg2 = args[2].(ErrataListFilters)
		}
		var arg3 PageOptions
		if args[3] != nil {
			arg3 = args[3].(PageOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockTangy_RpmRepositoryVersionErrataList_Call) Return(errataListItems []ErrataListItem, n int, err error) *MockTangy_RpmRepositoryVersionErrataList_Call {
	_c.Call.Return(errataListItems, n, err)
	return _c
}

func (_c *MockTangy_RpmRepositoryVersionErrataList_Call) RunAndReturn(run func(ctx context.Context, hrefs []string, filterOpts ErrataListFilters, pageOpts PageOptions) ([]ErrataListItem, int, error)) *MockTangy_RpmRepositoryVersionErrataList_Call {
	_c.Call.Return(run)
	return _c
}

// RpmRepositoryVersionModuleStreamsList provides a mock function for the type MockTangy
func (_mock *MockTangy) RpmRepositoryVersionModuleStreamsList(ctx context.Context, hrefs []string, filterOpts ModuleStreamListFilters, sortBy string) ([]ModuleStreams, error) {
	ret := _mock.Called(ctx, hrefs, filterOpts, sortBy)

	if len(ret) == 0 {
		panic("no return value specified for RpmRepositoryVersionModuleStreamsList")
	}

	var r0 []ModuleStreams
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, ModuleStreamListFilters, string) ([]ModuleStreams, error)); ok {
		return returnFunc(ctx, hrefs, filterOpts, sortBy)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, ModuleStreamListFilters, string) []ModuleStreams); ok {
		r0 = returnFunc(ctx, hrefs, filterOpts, sortBy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ModuleStreams)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []string, ModuleStreamListFilters, string) error); ok {
		r1 = returnFunc(ctx, hrefs, filterOpts, sortBy)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTangy_RpmRepositoryVersionModuleStreamsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RpmRepositoryVersionModuleStreamsList'
type MockTangy_RpmRepositoryVersionModuleStreamsList_Call struct {
	*mock.Call
}

// RpmRepositoryVersionModuleStreamsList is a helper method to define mock.On call
//   - ctx context.Context
//   - hrefs []string
//   - filterOpts ModuleStreamListFilters
//   - sortBy string
func (_e *MockTangy_Expecter) RpmRepositoryVersionModuleStreamsList(ctx interface{}, hrefs interface{}, filterOpts interface{}, sortBy interface{}) *MockTangy_RpmRepositoryVersionModuleStreamsList_Call {
	return &MockTangy_RpmRepositoryVersionModuleStreamsList_Call{Call: _e.mock.On("RpmRepositoryVersionModuleStreamsList", ctx, hrefs, filterOpts, sortBy)}
}

func (_c *MockTangy_RpmRepositoryVersionModuleStreamsList_Call) Run(run func(ctx context.Context, hrefs []string, filterOpts ModuleStreamListFilters, sortBy string)) *MockTangy_RpmRepositoryVersionModuleStreamsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		var arg2 ModuleStreamListFilters
		if args[2] != nil {
			arg2 = args[2].(ModuleStreamListFilters)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockTangy_RpmRepositoryVersionModuleStreamsList_Call) Return(moduleStreamss []ModuleStreams, err error) *MockTangy_RpmRepositoryVersionModuleStreamsList_Call {
	_c.Call.Return(moduleStreamss, err)
	return _c
}

func (_c *MockTangy_RpmRepositoryVersionModuleStreamsList_Call) RunAndReturn(run func(ctx context.Context, hrefs []string, filterOpts ModuleStreamListFilters, sortBy string) ([]ModuleStreams, error)) *MockTangy_RpmRepositoryVersionModuleStreamsList_Call {
	_c.Call.Return(run)
	return _c
}

// RpmRepositoryVersionPackageGroupSearch provides a mock function for the type MockTangy
func (_mock *MockTangy) RpmRepositoryVersionPackageGroupSearch(ctx context.Context, hrefs []string, search string, limit int) ([]RpmPackageGroupSearch, error) {
	ret := _mock.Called(ctx, hrefs, search, limit)

	if len(ret) == 0 {
		panic("no return value specified for RpmRepositoryVersionPackageGroupSearch")
	}

	var r0 []RpmPackageGroupSearch
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, string, int) ([]RpmPackageGroupSearch, error)); ok {
		return returnFunc(ctx, hrefs, search, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, string, int) []RpmPackageGroupSearch); ok {
		r0 = returnFunc(ctx, hrefs, search, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]RpmPackageGroupSearch)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []string, string, int) error); ok {
		r1 = returnFunc(ctx, hrefs, search, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTangy_RpmRepositoryVersionPackageGroupSearch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RpmRepositoryVersionPackageGroupSearch'
type MockTangy_RpmRepositoryVersionPackageGroupSearch_Call struct {
	*mock.Call
}

// RpmRepositoryVersionPackageGroupSearch is a helper method to define mock.On call
//   - ctx context.Context
//   - hrefs []string
//   - search string
//   - limit int
func (_e *MockTangy_Expecter) RpmRepositoryVersionPackageGroupSearch(ctx interface{}, hrefs interface{}, search interface{}, limit interface{}) *MockTangy_RpmRepositoryVersionPackageGroupSearch_Call {
	return &MockTangy_RpmRepositoryVersionPackageGroupSearch_Call{Call: _e.mock.On("RpmRepositoryVersionPackageGroupSearch", ctx, hrefs, search, limit)}
}

func (_c *MockTangy_RpmRepositoryVersionPackageGroupSearch_Call) Run(run func(ctx context.Context, hrefs []string, search string, limit int)) *MockTangy_RpmRepositoryVersionPackageGroupSearch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockTangy_RpmRepositoryVersionPackageGroupSearch_Call) Return(rpmPackageGroupSearchs []RpmPackageGroupSearch, err error) *MockTangy_RpmRepositoryVersionPackageGroupSearch_Call {
	_c.Call.Return(rpmPackageGroupSearchs, err)
	return _c
}

func (_c *MockTangy_RpmRepositoryVersionPackageGroupSearch_Call) RunAndReturn(run func(ctx context.Context, hrefs []string, search string, limit int) ([]RpmPackageGroupSearch, error)) *MockTangy_RpmRepositoryVersionPackageGroupSearch_Call {
	_c.Call.Return(run)
	return _c
}

// RpmRepositoryVersionPackageList provides a mock function for the type MockTangy
func (_mock *MockTangy) RpmRepositoryVersionPackageList(ctx context.Context, hrefs []string, filterOpts RpmListFilters, pageOpts PageOptions) ([]RpmListItem, int, error) {
	ret := _mock.Called(ctx, hrefs, filterOpts, pageOpts)

	if len(ret) == 0 {
		panic("no return value specified for RpmRepositoryVersionPackageList")
	}

	var r0 []RpmListItem
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, RpmListFilters, PageOptions) ([]RpmListItem, int, error)); ok {
		return returnFunc(ctx, hrefs, filterOpts, pageOpts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, RpmListFilters, PageOptions) []RpmListItem); ok {
		r0 = returnFunc(ctx, hrefs, filterOpts, pageOpts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]RpmListItem)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []string, RpmListFilters, PageOptions) int); ok {
		r1 = returnFunc(ctx, hrefs, filterOpts, pageOpts)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, []string, RpmListFilters, PageOptions) error); ok {
		r2 = returnFunc(ctx, hrefs, filterOpts, pageOpts)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockTangy_RpmRepositoryVersionPackageList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RpmRepositoryVersionPackageList'
type MockTangy_RpmRepositoryVersionPackageList_Call struct {
	*mock.Call
}

// RpmRepositoryVersionPackageList is a helper method to define mock.On call
//   - ctx context.Context
//   - hrefs []string
//   - filterOpts RpmListFilters
//   - pageOpts PageOptions
func (_e *MockTangy_Expecter) RpmRepositoryVersionPackageList(ctx interface{}, hrefs interface{}, filterOpts interface{}, pageOpts interface{}) *MockTangy_RpmRepositoryVersionPackageList_Call {
	return &MockTangy_RpmRepositoryVersionPackageList_Call{Call: _e.mock.On("RpmRepositoryVersionPackageList", ctx, hrefs, filterOpts, pageOpts)}
}

func (_c *MockTangy_RpmRepositoryVersionPackageList_Call) Run(run func(ctx context.Context, hrefs []string, filterOpts RpmListFilters, pageOpts PageOptions)) *MockTangy_RpmRepositoryVersionPackageList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		var arg2 RpmListFilters
		if args[2] != nil {
			arg2 = args[2].(RpmListFilters)
		}
		var arg3 PageOptions
		if args[3] != nil {
			arg3 = args[3].(PageOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockTangy_RpmRepositoryVersionPackageList_Call) Return(rpmListItems []RpmListItem, n int, err error) *MockTangy_RpmRepositoryVersionPackageList_Call {
	_c.Call.Return(rpmListItems, n, err)
	return _c
}

func (_c *MockTangy_RpmRepositoryVersionPackageList_Call) RunAndReturn(run func(ctx context.Context, hrefs []string, filterOpts RpmListFilters, pageOpts PageOptions) ([]RpmListItem, int, error)) *MockTangy_RpmRepositoryVersionPackageList_Call {
	_c.Call.Return(run)
	return _c
}

// RpmRepositoryVersionPackageSearch provides a mock function for the type MockTangy
func (_mock *MockTangy) RpmRepositoryVersionPackageSearch(ctx context.Context, hrefs []string, search string, limit int) ([]RpmPackageSearch, error) {
	ret := _mock.Called(ctx, hrefs, search, limit)

	if len(ret) == 0 {
		panic("no return value specified for RpmRepositoryVersionPackageSearch")
	}

	var r0 []RpmPackageSearch
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, string, int) ([]RpmPackageSearch, error)); ok {
		return returnFunc(ctx, hrefs, search, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, string, int) []RpmPackageSearch); ok {
		r0 = returnFunc(ctx, hrefs, search, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]RpmPackageSearch)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []string, string, int) error); ok {
		r1 = returnFunc(ctx, hrefs, search, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTangy_RpmRepositoryVersionPackageSearch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RpmRepositoryVersionPackageSearch'
type MockTangy_RpmRepositoryVersionPackageSearch_Call struct {
	*mock.Call
}

// RpmRepositoryVersionPackageSearch is a helper method to define mock.On call
//   - ctx context.Context
//   - hrefs []string
//   - search string
//   - limit int
func (_e *MockTangy_Expecter) RpmRepositoryVersionPackageSearch(ctx interface{}, hrefs interface{}, search interface{}, limit interface{}) *MockTangy_RpmRepositoryVersionPackageSearch_Call {
	return &MockTangy_RpmRepositoryVersionPackageSearch_Call{Call: _e.mock.On("RpmRepositoryVersionPackageSearch", ctx, hrefs, search, limit)}
}

func (_c *MockTangy_RpmRepositoryVersionPackageSearch_Call) Run(run func(ctx context.Context, hrefs []string, search string, limit int)) *MockTangy_RpmRepositoryVersionPackageSearch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockTangy_RpmRepositoryVersionPackageSearch_Call) Return(rpmPackageSearchs []RpmPackageSearch, err error) *MockTangy_RpmRepositoryVersionPackageSearch_Call {
	_c.Call.Return(rpmPackageSearchs, err)
	return _c
}

func (_c *MockTangy_RpmRepositoryVersionPackageSearch_Call) RunAndReturn(run func(ctx context.Context, hrefs []string, search string, limit int) ([]RpmPackageSearch, error)) *MockTangy_RpmRepositoryVersionPackageSearch_Call {
	_c.Call.Return(run)
	return _c
}
